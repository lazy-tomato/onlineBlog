import{_ as l,r,o as t,c as d,a as e,b as i,d as n,e as s}from"./app.acfc35a6.js";const c={},h=s(`<h1 id="重排重绘" tabindex="-1"><a class="header-anchor" href="#重排重绘" aria-hidden="true">#</a> 重排重绘</h1><h2 id="_1-概念" tabindex="-1"><a class="header-anchor" href="#_1-概念" aria-hidden="true">#</a> 1. 概念：</h2><h3 id="_1-1-重排-回流" tabindex="-1"><a class="header-anchor" href="#_1-1-重排-回流" aria-hidden="true">#</a> 1.1 重排/回流</h3><p>当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><h3 id="_1-2-重绘" tabindex="-1"><a class="header-anchor" href="#_1-2-重绘" aria-hidden="true">#</a> 1.2 重绘</h3><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h2 id="_2-浏览器对于重排重绘的优化" tabindex="-1"><a class="header-anchor" href="#_2-浏览器对于重排重绘的优化" aria-hidden="true">#</a> 2. 浏览器对于重排重绘的优化</h2><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 当你访问以下属性或方法时，浏览器会立刻清空队列：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>clientWidth、clientHeight、clientTop、clientLeft

offsetWidth、offsetHeight、offsetTop、offsetLeft

scrollWidth、scrollHeight、scrollTop、scrollLeft

width、height

getComputedStyle()

getBoundingClientRect()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-如何减少重排重绘" tabindex="-1"><a class="header-anchor" href="#_3-如何减少重排重绘" aria-hidden="true">#</a> 3. 如何减少重排重绘</h2><h3 id="css" tabindex="-1"><a class="header-anchor" href="#css" aria-hidden="true">#</a> CSS</h3><ul><li>避免使用 table 布局。</li><li>尽可能在 DOM 树的最末端改变 class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。</li><li>避免使用 CSS 表达式（例如：calc()）。</li></ul><h3 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript" aria-hidden="true">#</a> JavaScript</h3><ul><li>避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。</li><li>避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。</li><li>也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h2 id="_4-借鉴的博客" tabindex="-1"><a class="header-anchor" href="#_4-借鉴的博客" aria-hidden="true">#</a> 4. 借鉴的博客</h2>`,15),o={href:"https://juejin.cn/post/6844903779700047885",target:"_blank",rel:"noopener noreferrer"},u={href:"https://juejin.cn/post/6844903569087266823",target:"_blank",rel:"noopener noreferrer"},_=e("h2",{id:"_5-番茄自己的总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_5-番茄自己的总结","aria-hidden":"true"},"#"),i(" 5.番茄自己的总结")],-1),f=e("ol",null,[e("li",null,"改变了元素的位置的情况，就需要重排（回流）。进改变元素的颜色等不改变元素位置的情况，就需要重绘。"),e("li",null,"元素改变，重新渲染会花费一定的性能，主要的目标就是，减少不必要的性能损耗，和极优的用户体验。"),e("li",null,"浏览器本身会做一个缓存机制的处理，会将所有的重排重绘的操作记录在一个队列中，当达到一个阈值的时候，开始清空队列。但是访问某些属性的时候，由于对精度的要求，会导致立即重排重绘。"),e("li",null,"减少操作样式的频率，操作样式统一修改，建少读取特殊属性的平路，脱离文档流（减少对以其他元素的影响）。")],-1);function v(p,b){const a=r("ExternalLinkIcon");return t(),d("div",null,[h,e("ul",null,[e("li",null,[e("a",o,[i("重排重绘"),n(a)])]),e("li",null,[e("a",u,[i("浏览器的回流与重绘 (Reflow & Repaint)"),n(a)])])]),_,f])}const x=l(c,[["render",v],["__file","06.重排重绘.html.vue"]]);export{x as default};
