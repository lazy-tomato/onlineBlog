import{_ as r,r as s,o as i,c as l,a as e,b as a,d as o,e as d}from"./app.acfc35a6.js";const t="/onlineBlog/assets/image-20230301232845649.dd7459e2.png",c="/onlineBlog/assets/image-20230301233704616.7c63f2fb.png",h="/onlineBlog/assets/image-20230301233808910.b07f0574.png",_={},p=d(`<h1 id="前端基础组件库如何实时调试-软链接" tabindex="-1"><a class="header-anchor" href="#前端基础组件库如何实时调试-软链接" aria-hidden="true">#</a> 前端基础组件库如何实时调试，软链接</h1><h2 id="start" tabindex="-1"><a class="header-anchor" href="#start" aria-hidden="true">#</a> start</h2><ul><li>最近在做基础组件库的重构工作，遇到的第一个问题就是，组件库的代码修改完毕了，如何调试呢？</li><li>组件库的代码在供外部使用的时候，<strong>通常是</strong>通过打包输出 <code>lib</code> 或者 <code>dist</code> 文件，上传 <code>npm</code> 库，供其他项目调用。</li><li>但是在我调试源码的时候，打包生成了 <code>lib</code> ，再去其他项目调用就不是很方便了。</li></ul><h2 id="解决思路" tabindex="-1"><a class="header-anchor" href="#解决思路" aria-hidden="true">#</a> 解决思路</h2><p>目前想到的解决思路：</p><ol><li><p>我搭建一个项目A，一个组件库项目B</p></li><li><p>项目A中的 <code>node_modules</code> 中软链接项目B。</p></li><li><p>启动项目A，修改项目B，在项目A中实时查看效果。</p></li></ol><h2 id="软链接的实现方式" tabindex="-1"><a class="header-anchor" href="#软链接的实现方式" aria-hidden="true">#</a> 软链接的实现方式</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># mac/linux</span>
<span class="token function">ln</span> <span class="token parameter variable">-s</span> 源文件 目标文件

<span class="token comment"># windows</span>
mklink 当前目录 目标目录
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相关小知识" tabindex="-1"><a class="header-anchor" href="#相关小知识" aria-hidden="true">#</a> 相关小知识</h2><h3 id="_1-ln-s" tabindex="-1"><a class="header-anchor" href="#_1-ln-s" aria-hidden="true">#</a> 1. ln -s</h3><h4 id="_1-1-基础解释" tabindex="-1"><a class="header-anchor" href="#_1-1-基础解释" aria-hidden="true">#</a> 1.1 基础解释</h4><p><code>ln</code> 它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><h4 id="_1-2-基础使用" tabindex="-1"><a class="header-anchor" href="#_1-2-基础使用" aria-hidden="true">#</a> 1.2 基础使用</h4><p><code>ln -s 源文件 目标文件</code></p><h4 id="_1-3-参数说明" tabindex="-1"><a class="header-anchor" href="#_1-3-参数说明" aria-hidden="true">#</a> 1.3 参数说明</h4><ul><li><code>-s</code> 软链接：只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间；</li><li>不带<code>-s</code> 硬链接：它会在你选定的位置上生成一个和源文件大小相同的文件；</li></ul><blockquote><p>无论是软链接还是硬链接，文件都保持同步变化</p></blockquote><h3 id="_2-node-modules-寻找顺序" tabindex="-1"><a class="header-anchor" href="#_2-node-modules-寻找顺序" aria-hidden="true">#</a> 2. node_modules 寻找顺序？</h3><blockquote><p>由于涉及到了 <code>node_modules </code> ，所以就有一个项目中 <code>node_modules </code> 如何寻找的逻辑了，这里在复习一下。</p></blockquote><h4 id="_2-1-require-commonjs加载模块的顺序" tabindex="-1"><a class="header-anchor" href="#_2-1-require-commonjs加载模块的顺序" aria-hidden="true">#</a> 2.1 require -commonjs加载模块的顺序</h4>`,21),u={href:"https://javascript.ruanyifeng.com/nodejs/module.html#toc7",target:"_blank",rel:"noopener noreferrer"},m={href:"https://juejin.cn/post/6994224541312483336#heading-6",target:"_blank",rel:"noopener noreferrer"},b=d('<p><img src="'+t+'" alt="image-20230301232845649"></p><p><img src="'+c+'" alt="image-20230301233704616"></p><h4 id="_2-2-import加载顺序-es-modules" tabindex="-1"><a class="header-anchor" href="#_2-2-import加载顺序-es-modules" aria-hidden="true">#</a> 2.2 import加载顺序？<code>es modules</code></h4><blockquote><p>印象中，好像只了解到了 require的加载顺序，很少提到 <code>esmodules</code> 中 import 的加载顺序，所以思考了一下。</p></blockquote><p>搜索了全网目前得到的答案：<code>import/export 目前尚未被 node 支持，因此实际使用都是转换成 require 的</code></p><blockquote><p>我觉得他说的还是很有道理的，理论上我编写一个 vue 工程，基于 webpack 打包编译，webpack 本身也是手动实现一个require罢了。</p><p>所以这里的加载机制或许可以默认 import 等同于 node的require；</p><p>当然后续真的找到问题的答案了，我再回来纠正。</p></blockquote>',6),f={href:"https://segmentfault.com/q/1010000013536010",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,[e("img",{src:h,alt:"image-20230301233808910"})],-1),k=e("h2",{id:"end",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#end","aria-hidden":"true"},"#"),a(" End")],-1),x=e("ul",null,[e("li",null,"这就是今天的收获，还不错，后续继续加油！")],-1);function v(q,B){const n=s("ExternalLinkIcon");return i(),l("div",null,[p,e("p",null,[e("a",u,[a("阮一峰-require加载node_modules的顺序"),o(n)])]),e("p",null,[e("a",m,[a("require 文件加载流程"),o(n)])]),b,e("p",null,[e("a",f,[a("出处点击这里"),o(n)])]),g,k,x])}const w=r(_,[["render",v],["__file","9.基础组件库供主项目调用，如何处理-软链接.html.vue"]]);export{w as default};
