import{_ as i,o as l,c as e,e as a}from"./app.acfc35a6.js";const r="/onlineBlog/assets/image-20221208202450855.7331ea47.png",t="/onlineBlog/assets/image-20221208210044097.2040a08d.png",o={},n=a('<h1 id="浏览器中的进程" tabindex="-1"><a class="header-anchor" href="#浏览器中的进程" aria-hidden="true">#</a> 浏览器中的进程</h1><h2 id="start" tabindex="-1"><a class="header-anchor" href="#start" aria-hidden="true">#</a> start</h2><ul><li>上一篇文章，学习到了如何区分进程和线程。</li><li>在这里再复习一下，<strong>进程</strong>类似于<strong>一个工厂</strong>，<strong>线程</strong>类似于工厂的工人，一个工厂可以有一个或多个工人。</li></ul><h2 id="_1-浏览器的进程" tabindex="-1"><a class="header-anchor" href="#_1-浏览器的进程" aria-hidden="true">#</a> 1. 浏览器的进程</h2><p>一个浏览器中有很多的进程，我以谷歌浏览器为例，做一下说明：</p><h3 id="_1-1-blink-内核包含的主要进程" tabindex="-1"><a class="header-anchor" href="#_1-1-blink-内核包含的主要进程" aria-hidden="true">#</a> 1.1 Blink 内核包含的主要进程</h3><ul><li><p>谷歌浏览器使用的是 Blink 内核。</p></li><li><p>Blink 内核包含的主要进程如下：</p><ol><li><p>Browser 进程：主进程，只有一个。</p><blockquote><p>它的作用有</p><ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></blockquote></li><li><p>Renderer 进程：默认每个页面一个，互不影响。主要作用为解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</p></li><li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p></li><li><p>GPU 进程：最多一个，用于 3D 绘制等</p></li></ol></li></ul><h3 id="_1-2-查看浏览器的任务管理器" tabindex="-1"><a class="header-anchor" href="#_1-2-查看浏览器的任务管理器" aria-hidden="true">#</a> 1.2 查看浏览器的任务管理器</h3><p>上面说了一堆进程，有点晕，我们查看一下浏览器的任务管理器，用可视化的方式来看看进程。</p><blockquote><p>例如：谷歌浏览器右上角竖着三个点的菜单--&gt;更多工具--&gt;任务管理器</p></blockquote><p><img src="'+r+'" alt="image-20221208202450855"></p><p><img src="'+t+'" alt="image-20221208210044097"></p><p>看到上图的任务管理器，可以验证我们所说的进程分类。</p><h3 id="_1-3-浏览器多进程的好处" tabindex="-1"><a class="header-anchor" href="#_1-3-浏览器多进程的好处" aria-hidden="true">#</a> 1.3 浏览器多进程的好处？</h3><ul><li><p>避免单个 page crash 影响整个浏览器</p><blockquote><p>page crash 页面崩溃</p></blockquote></li><li><p>避免第三方插件 crash 影响整个浏览器</p></li><li><p>多进程充分利用多核优势</p></li><li><p>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</p></li></ul><h3 id="_1-4-小结" tabindex="-1"><a class="header-anchor" href="#_1-4-小结" aria-hidden="true">#</a> 1.4 小结</h3><p>简单来说，记住一点，浏览器是由多个进程组成的。</p><h2 id="_2-渲染进程" tabindex="-1"><a class="header-anchor" href="#_2-渲染进程" aria-hidden="true">#</a> 2.渲染进程</h2><p>浏览器有这么多进程，我们更应该关注哪一个进程呢？</p><p>答：<strong>渲染进程</strong></p><blockquote><p>页面的渲染，JS 的执行，事件的循环，都在这个进程内进行。</p></blockquote><h3 id="_2-1-渲染进程包含那些线程" tabindex="-1"><a class="header-anchor" href="#_2-1-渲染进程包含那些线程" aria-hidden="true">#</a> 2.1 渲染进程包含那些线程？</h3><ol><li>GUI 渲染线程 <ul><li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，<strong>GUI 渲染线程与 JS 引擎线程是互斥的</strong>，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中<strong>等到 JS 引擎空闲时</strong>立即被执行。</li></ul></li><li>JS 引擎线程 <ul><li>也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li><li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序</li><li>同样注意，<strong>GUI 渲染线程与 JS 引擎线程是互斥的</strong>，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul></li><li>事件触发线程 <ul><li>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li><li>注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</li></ul></li><li>定时触发器线程 <ul><li>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）</li><li>注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li></ul></li><li>异步 http 请求线程 <ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul></li></ol><h3 id="_2-2-小结" tabindex="-1"><a class="header-anchor" href="#_2-2-小结" aria-hidden="true">#</a> 2.2 小结</h3><p>看完上述的信息之后，有什么用？</p><p>我总结一下我自己的收获</p><ol><li><p>一个进程中可以有一个或多个线程。</p></li><li><p>执行 JS 的代码的，其实只是渲染进程中的一个线程而已。</p></li><li><p>所以再看到<code>JS是单线程的</code>这句话就很好理解了。</p></li><li><p>但是单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><blockquote><ul><li>JS 执行会阻断页面的渲染（GUI 渲染线程与 JS 引擎线程是互斥的）</li><li>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</li><li>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。（<strong>这个多线程由浏览器提供，且不可操作 DOM</strong>）</li></ul></blockquote></li></ol><h3 id="end" tabindex="-1"><a class="header-anchor" href="#end" aria-hidden="true">#</a> end</h3><ul><li>本文学习了浏览器多个进程，</li><li>了解到其实执行 JS 的，是渲染进程中众多线程的其中一个。</li><li>由于 JS 单线程的本质，针对耗时长，阻塞页面渲染的逻辑，就需要引入额外的处理方式。就是我们下一篇文章会说到的 事件循环<code>event loop</code>。</li></ul>',29),s=[n];function p(d,c){return l(),e("div",null,s)}const u=i(o,[["render",p],["__file","2.浏览器中的进程.html.vue"]]);export{u as default};
