import{_ as e,o as i,c as a,e as l}from"./app.acfc35a6.js";const d={},o=l('<h1 id="执行上下文" tabindex="-1"><a class="header-anchor" href="#执行上下文" aria-hidden="true">#</a> 执行上下文</h1><h2 id="执行上下文的概念" tabindex="-1"><a class="header-anchor" href="#执行上下文的概念" aria-hidden="true">#</a> 执行上下文的概念</h2><p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。</p><blockquote><p>粗暴的理解：执行上下文就是 JS 代码执行的环境。</p></blockquote><h2 id="执行上下文的类型" tabindex="-1"><a class="header-anchor" href="#执行上下文的类型" aria-hidden="true">#</a> 执行上下文的类型</h2><ol><li>全局执行上下文 <blockquote><p>只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。</p></blockquote></li><li>函数执行上下文 <blockquote><p>存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p></blockquote></li><li><code>Eval</code> 函数执行上下文 <blockquote><p>指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用</p></blockquote></li></ol><h2 id="执行上下文栈" tabindex="-1"><a class="header-anchor" href="#执行上下文栈" aria-hidden="true">#</a> 执行上下文栈</h2><ul><li>执行上下文栈，用来存储代码执行期间创建的所有执行上下文的 <strong>栈结构</strong>。 <blockquote><p>栈结构，就是一个数组，但是只能从尾部操作，然后出栈的时候，后进先出的逻辑。</p></blockquote></li></ul><h2 id="执行上下文的创建" tabindex="-1"><a class="header-anchor" href="#执行上下文的创建" aria-hidden="true">#</a> 执行上下文的创建</h2><ol><li>创建阶段</li><li>执行阶段</li></ol><h3 id="_1-1-确定-this" tabindex="-1"><a class="header-anchor" href="#_1-1-确定-this" aria-hidden="true">#</a> 1.1 确定 <code>this</code>；</h3><h4 id="_1-1-1-全局执行上下文" tabindex="-1"><a class="header-anchor" href="#_1-1-1-全局执行上下文" aria-hidden="true">#</a> 1.1.1 全局执行上下文</h4><ul><li><code>this</code> 的值指向全局对象，在浏览器中 <code>this</code> 的值指向 <code>window</code> 对象，而在 nodejs 中指向这个文件的 <code>module</code> 对象。</li></ul><h4 id="_1-1-2-函数执行上下文" tabindex="-1"><a class="header-anchor" href="#_1-1-2-函数执行上下文" aria-hidden="true">#</a> 1.1.2 函数执行上下文</h4><ul><li><code>this</code> 指向没啥好说的，五种情况。</li><li>但是需要注意，执行上下文，是 JS 代码执行的时候创建的。就比如我一个函数调用两次，那么就会创建两个执行上下文来对应这两次调用。</li><li>与之相关的 <code>this</code> 指向，和函数调用的方式有关。</li></ul><h3 id="_1-2-初始化-lexicalenvironment-词法环境" tabindex="-1"><a class="header-anchor" href="#_1-2-初始化-lexicalenvironment-词法环境" aria-hidden="true">#</a> 1.2 初始化 <code>LexicalEnvironment</code>（词法环境）；</h3><ul><li>环境记录（存储变量和函数声明的实际位置）</li><li>对外部环境的引用（访问外部词法环境）</li></ul><h4 id="_1-2-1-全局执行上下文" tabindex="-1"><a class="header-anchor" href="#_1-2-1-全局执行上下文" aria-hidden="true">#</a> 1.2.1 全局执行上下文</h4><ul><li>拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</li><li>没有外部环境，其外部环境引用为 null。</li></ul><h4 id="_1-2-2-函数执行上下文" tabindex="-1"><a class="header-anchor" href="#_1-2-2-函数执行上下文" aria-hidden="true">#</a> 1.2.2 函数执行上下文</h4><ul><li>用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象</li><li>对外部环境的引用</li></ul><h3 id="_1-3-初始化-variableenvironment-变量环境" tabindex="-1"><a class="header-anchor" href="#_1-3-初始化-variableenvironment-变量环境" aria-hidden="true">#</a> 1.3 初始化 <code>VariableEnvironment</code>（变量环境）；</h3><p>类似 词法环境，</p><p>在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。</p><ol start="2"><li>执行阶段 此阶段，完成对所有变量的分配，最后执行代码。</li></ol><h2 id="换一种角度思考" tabindex="-1"><a class="header-anchor" href="#换一种角度思考" aria-hidden="true">#</a> 换一种角度思考</h2><p>执行上下文可以理解为 一个对象</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>全局的变量对象</p><ol><li>window （全局上下文的变量对象初始化是全局对象）</li></ol><p>函数的变量对象</p><ol><li>函数上下文的变量对象初始化只包括 Arguments 对象；</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值；</li><li>在代码执行阶段，会再次修改变量对象的属性值；</li></ol>',32),h=[o];function r(c,n){return i(),a("div",null,h)}const s=e(d,[["render",r],["__file","1.执行上下文.html.vue"]]);export{s as default};
